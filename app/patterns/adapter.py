"""
Adapter Pattern Implementation
Export adapters for converting experiment data to various formats
"""
from abc import ABC, abstractmethod
from typing import List, Dict, Any
import json
from datetime import datetime
from bson import ObjectId
from io import StringIO


class ExportAdapter(ABC):
    """
    Abstract adapter for exporting conjoint experiment data.
    Implements Adapter pattern to convert MongoDB data to analysis formats.
    """
    
    @abstractmethod
    def export(self, data: List[Dict]) -> str:
        """Export data to target format."""
        pass
    
    @abstractmethod
    def get_content_type(self) -> str:
        """Get MIME content type for the export."""
        pass
    
    @abstractmethod
    def get_file_extension(self) -> str:
        """Get file extension for the export."""
        pass
    
    def _serialize_value(self, value: Any) -> Any:
        """Serialize special types to string."""
        if isinstance(value, ObjectId):
            return str(value)
        elif isinstance(value, datetime):
            return value.isoformat()
        elif isinstance(value, dict):
            return {k: self._serialize_value(v) for k, v in value.items()}
        elif isinstance(value, list):
            return [self._serialize_value(v) for v in value]
        return value


class CSVExportAdapter(ExportAdapter):
    """
    Adapter for exporting to CSV format.
    Compatible with R, Python pandas, Excel.
    """
    
    def __init__(self, delimiter: str = ','):
        self.delimiter = delimiter
    
    def export(self, data: List[Dict]) -> str:
        if not data:
            return ""
        
        output = StringIO()
        
        # Flatten nested structures and get all headers
        flattened_data = [self._flatten_dict(row) for row in data]
        headers = self._get_all_headers(flattened_data)
        
        # Write header row
        output.write(self.delimiter.join(headers) + '\n')
        
        # Write data rows
        for row in flattened_data:
            values = []
            for header in headers:
                value = row.get(header, '')
                value = self._serialize_value(value)
                # Escape values containing delimiter or newlines
                if isinstance(value, str) and (self.delimiter in value or '\n' in value):
                    value = f'"{value}"'
                values.append(str(value) if value is not None else '')
            output.write(self.delimiter.join(values) + '\n')
        
        return output.getvalue()
    
    def _flatten_dict(self, d: Dict, parent_key: str = '', sep: str = '_') -> Dict:
        """Flatten nested dictionary."""
        items = []
        for k, v in d.items():
            new_key = f"{parent_key}{sep}{k}" if parent_key else k
            if isinstance(v, dict):
                items.extend(self._flatten_dict(v, new_key, sep).items())
            else:
                items.append((new_key, self._serialize_value(v)))
        return dict(items)
    
    def _get_all_headers(self, data: List[Dict]) -> List[str]:
        """Get all unique headers from data."""
        headers = set()
        for row in data:
            headers.update(row.keys())
        return sorted(headers)
    
    def get_content_type(self) -> str:
        return 'text/csv'
    
    def get_file_extension(self) -> str:
        return 'csv'


class JSONExportAdapter(ExportAdapter):
    """
    Adapter for exporting to JSON format.
    Compatible with JavaScript, Python, and most programming languages.
    """
    
    def __init__(self, pretty: bool = True):
        self.pretty = pretty
    
    def export(self, data: List[Dict]) -> str:
        serialized = [self._serialize_value(row) for row in data]
        
        if self.pretty:
            return json.dumps(serialized, indent=2)
        return json.dumps(serialized)
    
    def get_content_type(self) -> str:
        return 'application/json'
    
    def get_file_extension(self) -> str:
        return 'json'


class RExportAdapter(ExportAdapter):
    """
    Adapter for exporting to R-compatible format.
    Generates R code that creates a data frame.
    """
    
    def export(self, data: List[Dict]) -> str:
        if not data:
            return "# No data to export\ndf <- data.frame()"
        
        output = StringIO()
        output.write("# Conjoint Experiment Data Export\n")
        output.write("# Generated by Jack & Jill Conjoint System\n\n")
        
        # Flatten data
        flattened = [self._flatten_dict(row) for row in data]
        headers = self._get_all_headers(flattened)
        
        # Create vectors for each column
        output.write("# Create data vectors\n")
        for header in headers:
            safe_name = self._make_r_safe_name(header)
            values = [row.get(header, 'NA') for row in flattened]
            r_values = [self._to_r_value(v) for v in values]
            output.write(f"{safe_name} <- c({', '.join(r_values)})\n")
        
        # Create data frame
        output.write("\n# Combine into data frame\n")
        safe_headers = [self._make_r_safe_name(h) for h in headers]
        output.write(f"df <- data.frame({', '.join(safe_headers)})\n")
        
        # Add column name mapping
        output.write("\n# Original column names\n")
        output.write(f"colnames(df) <- c({', '.join([repr(h) for h in headers])})\n")
        
        return output.getvalue()
    
    def _flatten_dict(self, d: Dict, parent_key: str = '', sep: str = '_') -> Dict:
        """Flatten nested dictionary."""
        items = []
        for k, v in d.items():
            new_key = f"{parent_key}{sep}{k}" if parent_key else k
            if isinstance(v, dict):
                items.extend(self._flatten_dict(v, new_key, sep).items())
            else:
                items.append((new_key, self._serialize_value(v)))
        return dict(items)
    
    def _get_all_headers(self, data: List[Dict]) -> List[str]:
        """Get all unique headers."""
        headers = set()
        for row in data:
            headers.update(row.keys())
        return sorted(headers)
    
    def _make_r_safe_name(self, name: str) -> str:
        """Convert to R-safe variable name."""
        safe = name.replace('-', '_').replace(' ', '_').replace('.', '_')
        if safe[0].isdigit():
            safe = 'x' + safe
        return safe
    
    def _to_r_value(self, value: Any) -> str:
        """Convert Python value to R literal."""
        if value is None or value == 'NA':
            return 'NA'
        elif isinstance(value, bool):
            return 'TRUE' if value else 'FALSE'
        elif isinstance(value, (int, float)):
            return str(value)
        elif isinstance(value, str):
            return repr(value)
        return repr(str(value))
    
    def get_content_type(self) -> str:
        return 'text/plain'
    
    def get_file_extension(self) -> str:
        return 'R'


class PythonExportAdapter(ExportAdapter):
    """
    Adapter for exporting to Python/Pandas format.
    Generates Python code that creates a DataFrame.
    """
    
    def export(self, data: List[Dict]) -> str:
        if not data:
            return "# No data to export\nimport pandas as pd\ndf = pd.DataFrame()"
        
        output = StringIO()
        output.write("# Conjoint Experiment Data Export\n")
        output.write("# Generated by Jack & Jill Conjoint System\n\n")
        output.write("import pandas as pd\n")
        output.write("from datetime import datetime\n\n")
        
        # Serialize data
        serialized = [self._serialize_value(row) for row in data]
        
        output.write("# Raw data\n")
        output.write(f"data = {json.dumps(serialized, indent=2)}\n\n")
        output.write("# Create DataFrame\n")
        output.write("df = pd.json_normalize(data)\n")
        
        return output.getvalue()
    
    def get_content_type(self) -> str:
        return 'text/plain'
    
    def get_file_extension(self) -> str:
        return 'py'


class ExportAdapterFactory:
    """
    Factory for creating export adapters.
    Implements Factory pattern for adapter creation.
    """
    
    _adapters = {
        'csv': CSVExportAdapter,
        'json': JSONExportAdapter,
        'r': RExportAdapter,
        'python': PythonExportAdapter,
    }
    
    @classmethod
    def create(cls, format_type: str, **kwargs) -> ExportAdapter:
        """Create an export adapter for the specified format."""
        adapter_class = cls._adapters.get(format_type.lower())
        if not adapter_class:
            raise ValueError(f"Unknown export format: {format_type}")
        return adapter_class(**kwargs)
    
    @classmethod
    def get_available_formats(cls) -> List[str]:
        """Get list of available export formats."""
        return list(cls._adapters.keys())
    
    @classmethod
    def register_adapter(cls, format_type: str, adapter_class: type):
        """Register a custom export adapter."""
        cls._adapters[format_type.lower()] = adapter_class
